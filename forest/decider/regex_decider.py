import re

from forest.spec import Predicate
from forest.spec.expr import *
from .example_decider import Example, ExampleDecider
from .result import ok, bad
from ..dsl import ApplyNode
from ..logger import get_logger
from ..visitor import Interpreter

logger = get_logger('forest')


class RegexDecider(ExampleDecider):

    def __init__(self, interpreter: Interpreter, valid_examples: List[Example],
                 invalid_examples: List[Example], split_valid=None):
        super().__init__(interpreter, examples=[Example(x, True) for x in valid_examples] \
                                               + [Example(x, False) for x in invalid_examples])
        self.already_must_occur = set()
        self.valid_exs = valid_examples
        self.split_valid = split_valid

        # Ensure the split examples all have the same number of substrings
        assert self.split_valid is None or all(
            map(lambda x: len(x) == len(self.split_valid[0]), self.split_valid))

    def analyze(self, regex: ApplyNode):
        """
        Analyze the reason why a synthesized program fails if it does not
        pass all the tests.
        """
        if not self.has_failed_examples(regex):
            return ok()
        else:
            if regex.production.lhs.name == "Regex":
                new_predicates = self.traverse_regex(regex)
            else:
                new_predicates = self.traverse_program(regex, self._examples)

            if len(new_predicates) == 0:
                return bad()
            else:
                return bad(why=new_predicates)

    def traverse_regex(self, node: ApplyNode):
        """ Analyze regex programs """
        new_predicates = []
        # the top node is always concat if the program is generated by
        # Static or Dynamic Multi-tree enumerators
        assert self.split_valid is None or len(node.children) == len(self.split_valid[0])

        for tree_idx, tree in enumerate(node.children):
            if node.name == "concat" and node.has_children():
                # if one child does not have a match in any of the examples,
                # then it cannot happen as a direct top concat node
                regex = self.interpreter.eval(tree)
                if not self.always_matches_examples(regex):
                    new_predicate = Predicate("block_tree", [tree, tree_idx])
                    new_predicates.append(new_predicate)

                if self.split_valid is not None:
                    # MultiTree enumerator was used
                    assert len(node.children) == len(self.split_valid[0])
                    re_c = re.compile(regex)
                    matches = map(lambda ex: re_c.fullmatch(ex[tree_idx]) \
                                             is not None, self.split_valid)
                    if not all(matches):
                        new_predicate = Predicate("block_tree", [tree, tree_idx])
                        new_predicates.append(new_predicate)

            new_predicates += self._traverse_regex_rec(node.children[tree_idx], tree_idx)

        return new_predicates

    def _traverse_regex_rec(self, node, tree_idx):
        """ Auxiliary function for traverse_regex. """
        new_predicates = []
        production = node.production
        if production.is_function():
            if production.name == "concat":
                regex = self.interpreter.eval(node)
                if self.never_matches_examples(regex):
                    new_predicates.append(Predicate("block_subtree", [node, tree_idx]))

            elif production.name == "range":
                '''
                Block r{n,m} if
                    r{n} does not always occurs
                    r{m} never occurs
                '''
                regex = self.interpreter.eval(node, self.valid_exs[0])
                bounds = node.args[1].data.split(',')
                if len(bounds) < 2:  # sketches
                    return
                n = bounds[0]
                m = bounds[1]
                assert len(bounds) == 2
                # arg = (int(arg[0]), int(arg[1]))
                regex_n = re.sub('{\d+,\d+}$', '{' + n + '}', regex, 1)
                regex_m = re.sub('{\d+,\d+}$', '{' + m + '}', regex, 1)

                if not self.always_matches_examples(regex_n):
                    new_predicates.append(
                        Predicate("block_range_lower_bound", [node, tree_idx]))
                elif self.never_matches_examples(regex_m):
                    new_predicates.append(
                        Predicate("block_range_upper_bound", [node, tree_idx]))

            elif production.name == "kleene" or production.name == "posit":
                regex = self.interpreter.eval(node.children[0])
                regex = regex + regex
                if self.never_matches_examples(regex):
                    new_predicates.append(
                        Predicate("block_subtree", [node, tree_idx]))

            elif production.name == "re":
                char_node = node.children[0]
                assert (char_node.is_enum() and char_node.type.name == "RegexLit")
                st = str(char_node.data)
                # FIXME: What if char is always present but it is part of a char class?
                #  Then it can be the char class that must occur.
                if self.always_matches_examples(st) and \
                        '[' not in st and st not in self.already_must_occur:
                    self.already_must_occur.add(st)
                    new_predicates.append(
                        Predicate("char_must_occur", [char_node, tree_idx]))

        if node.has_children():
            for child in node.children:
                child_traverse = self._traverse_regex_rec(child, tree_idx)
                if child_traverse is not None and len(child_traverse) > 0:
                    return child_traverse

            return new_predicates
        else:
            return new_predicates

    def never_matches_examples(self, regex: str):
        """ Returns True if no example contains the given regex """
        rec = re.compile(regex)
        return not any(map(lambda ex: rec.search(ex[0]) is not None,
                           self.valid_exs))

    def always_matches_examples(self, regex: str):
        """ Returns True if all examples contain the given regex """
        rec = re.compile(regex)
        return all(map(lambda ex: rec.search(ex[0]) is not None, self.valid_exs))

    def traverse_program(self, program, examples):
        """ Traverse eventually non-regex programs """
        return []
